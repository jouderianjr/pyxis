// Containers defines all container rules based on device width.

@use "../lib";
@use "../tokens/containers" as *;
@use "breakpoints";
@use "sass:map";

// The gutter of container
$_gutter: lib.rem(lib.get($containers, gutter));

// Fluid dimension for small sizes
$_fluidWidth: calc(100vw - (#{$_gutter} * 2));

// The fluid containers of Pyxis
$_fluidContainers: (
  base: $_fluidWidth,
  xxsmall: $_fluidWidth,
  xsmall: $_fluidWidth,
  small: $_fluidWidth
);

// The containers of Pyxis
$_containers: map.merge($_fluidContainers, lib.get($containers, size));

// Returns the $breakpoint value from map $_containers
//
// @param {String} $breakpoint - Name of breakpoint
// @return {Number} The max-value of container in breakpoint
// @throw {Error}
@function _container($breakpoint) {
  @return lib.get($_containers, $breakpoint);
}

// Return the length of cycle
//
// @param {String} $breakpoint - Name of breakpoint
// @return {Number} The length of @for cycle
// @throw {Error}
@function _lengthOfBreakpointCycle($breakpoint) {
  @if lib.isNotNull($breakpoint) {
    @return index($_containers, $breakpoint _container($breakpoint)) - 1;
  }

  @return length($_containers);
}

// Returns the breakpoint name
//
// @param {String:Null} $breakpoint - Name of breakpoint
// @param {Number} $index - Index of breakpoint in $_containers
// @return {String:Null} The name of container or null
@function _untilBreakpoint($breakpoint, $index) {
  @if lib.isNotNull($breakpoint) {
    @return nth(nth($_containers, $index + 1), 1);
  }

  @return null;
}

// Include a container by `$fromBreakpoint` to `$toBreakpoint` value,
// outside the indicated breakpoints the container will be fluid.
// The container is based on `display: grid;` property.
//
// @param {String} $fromBreakpoint [base] - Name of start breakpoint
// @param {String} $toBreakpoint [null] - Name of end breakpoint
//
// @throw Error if `$fromBreakpoint` value is lower or equal to `$untilBreakpoint` value
@mixin container($fromBreakpoint: base, $untilBreakpoint: null) {
  display: grid;
  margin: 0 auto;

  @if(lib.isNotNull($untilBreakpoint) and breakpoints.isGreaterOrEqualTo($fromBreakpoint, $untilBreakpoint)) {
    @error "You cannot use a `$untilBreakpoint` value smaller or equal than `$fromBreakpoint` value";
  }

  $_indexFromBreakpoint: index($_containers, $fromBreakpoint _container($fromBreakpoint));

  @for $i from $_indexFromBreakpoint through _lengthOfBreakpointCycle($untilBreakpoint) {
    $_containerFromBreakpoint: nth(nth($_containers, $i), 1);

    @include breakpoints.mq($_containerFromBreakpoint, _untilBreakpoint($untilBreakpoint, $i)) {
      max-width: _container($_containerFromBreakpoint);
    }
  }
}

// Create atom classes for containers
@mixin createAtoms() {
  .container {
    @include container();
  }

  @each $breakpoint, $value in map-remove($_containers, base) {
    .container-from-#{$breakpoint} {
      @include container($breakpoint);
    }
  }
}
